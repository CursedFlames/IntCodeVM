use std::collections::{HashMap, VecDeque};

struct IntMemory {
	// TODO maybe store a second copy of memory in a format optimized for instructions?
	//      and only add to it when an instr is read for the first time
	//      and remove instrs when one of their values is changed in main memory
	// TODO can we use an array for this or does array size need to be known at compile time?
	dense_memory: Vec<i64>,
	sparse_memory: HashMap<i64, i64>,
	dense_length: i64,
}

impl IntMemory {
	pub fn new(mut program: Vec<i64>, dense_length: i64) -> IntMemory {
		if program.len() <= dense_length as usize {
			// Expand to dense_length with zeroes
			// if program.len() < dense_length as usize {
				program.resize(dense_length as usize, 0);
			// }
			IntMemory {
				dense_memory: program,
				sparse_memory: HashMap::new(),
				dense_length
			}
		} else {
			let sparse_segment = program.split_off(dense_length as usize);
			let mut sparse_memory = HashMap::new();
			for (i, x) in sparse_segment.iter().enumerate() {
				sparse_memory.insert(i as i64 + dense_length, *x);
			}
			IntMemory {
				dense_memory: program,
				sparse_memory,
				dense_length
			}
		}
	}

	pub fn get(&self, idx: i64) -> i64 {
		if idx < self.dense_length {
			self.dense_memory[idx as usize]
		} else {
			match self.sparse_memory.get(&idx) {
				Some(x) => *x,
				None => 0
			}
		}
	}

	pub fn set(&mut self, idx: i64, val: i64) {
		if idx < self.dense_length {
			self.dense_memory[idx as usize] = val;
		} else {
			self.sparse_memory.insert(idx, val);
		}
	}
}

pub struct IntVM {
	memory: IntMemory,
	instr_ptr: i64,
	offset: i64,
	input: VecDeque<i64>,
}

#[derive(PartialEq, Eq)]
enum StepResult {
	CONTINUE,
	HALT
}

const ARG_COUNTS: [i64; 10] = [0, 3, 3, 1, 1, 2, 2, 3, 3, 1];

impl IntVM {
	pub fn new(program: Vec<i64>, dense_length: i64, input: VecDeque<i64>) -> IntVM {
		IntVM {
			memory: IntMemory::new(program, dense_length),
			instr_ptr: 0,
			offset: 0,
			input,
		}
	}

	pub fn run(&mut self) -> Vec<i64> {
		let mut output = Vec::new();
		while self.step(&mut output) == StepResult::CONTINUE {}
		output
	}

	fn get_memory(&self, idx: i64) -> i64 {
		if idx < 0 {
			panic!("Attempted to read negative memory address {}", idx);
		}
		self.memory.get(idx)
	}

	fn set_memory(&mut self, idx: i64, val: i64) {
		if idx < 0 {
			panic!("Attempted to write to negative memory address {}", idx);
		}
		self.memory.set(idx, val);
	}

	fn get_arg_ptr(&self, offset: i64, mode: i64) -> i64 {
		let ptr = self.instr_ptr + offset;
		match mode {
			0 => self.get_memory(ptr),
			1 => ptr,
			2 => self.get_memory(ptr)+self.offset,
			_ => panic!("Received invalid argument mode {} at position {}, instruction index {}", mode, offset, self.instr_ptr)
		}
	}

	fn get_input(&mut self) -> std::option::Option<i64> {
		self.input.pop_front()
	}
	
	fn step(&mut self, output: &mut Vec<i64>) -> StepResult {
		let instr = self.get_memory(self.instr_ptr);

		// TODO negative instruction ints are undefined behavior?
		let opcode = (instr % 100) as usize;

		if opcode == 99 {return StepResult::HALT;}

		let mode1 = (instr / 100) % 10;
		let mode2 = (instr / 1000) % 10;
		let mode3 = (instr / 10000) % 10;

		let arg1_ptr = self.get_arg_ptr(1, mode1);
		let arg2_ptr = self.get_arg_ptr(2, mode2);
		let arg3_ptr = self.get_arg_ptr(3, mode3);
		
		let arg1 = self.get_memory(arg1_ptr);
		let arg2 = if ARG_COUNTS[opcode] > 1 {self.get_memory(arg2_ptr)} else {0};
		// let arg3 = if ARG_COUNTS[opcode] > 2 {self.get_memory(arg3_ptr)} else {0};

		match opcode {
			1 => self.set_memory(arg3_ptr, arg1+arg2),
			2 => self.set_memory(arg3_ptr, arg1*arg2),
			3 => {
				let val = self.get_input();
				match val {
					Some(x) => self.set_memory(arg1_ptr, x),
					None => return StepResult::HALT
				}
			}
			4 => output.push(arg1),
			5 => if arg1 != 0 {self.instr_ptr = arg2; return StepResult::CONTINUE},
			6 => if arg1 == 0 {self.instr_ptr = arg2; return StepResult::CONTINUE},
			7 => self.set_memory(arg3_ptr, if arg1 < arg2 {1} else {0}),
			8 => self.set_memory(arg3_ptr, if arg1 == arg2 {1} else {0}),
			9 => self.offset += arg1,
			_ => panic!("Received invalid opcode {} in instruction {} at memory index {}", opcode, instr, self.instr_ptr)
		}

		self.instr_ptr += 1 + ARG_COUNTS[opcode];
		StepResult::CONTINUE
	}
}

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn test_noop() {
		let mut vm = IntVM::new(vec![99], 10, VecDeque::new());
		let output = vm.run();
		assert_eq!(output, vec![]);
	}

	#[test]
	fn test_io() {
		let mut vm = IntVM::new(vec![3,0,4,0,99], 10,VecDeque::from(vec![100]));
		let output = vm.run();
		assert_eq!(output, vec![100]);
	}

	#[test]
	fn test_addition() {
		let mut vm = IntVM::new(vec![1,4,6,0,4,0,99], 10, VecDeque::new());
		let output = vm.run();
		assert_eq!(output, vec![103]);
	}

	#[test]
	fn test_multiplication() {
		let mut vm = IntVM::new(vec![2,4,6,0,4,0,99], 10, VecDeque::new());
		let output = vm.run();
		assert_eq!(output, vec![396]);
	}

	#[test]
	fn test_immediate_mode() {
		let mut vm = IntVM::new(vec![104,73,99], 10, VecDeque::new());
		let output = vm.run();
		assert_eq!(output, vec![73]);
	}

	#[test]
	fn test_negative_value() {
		let mut vm = IntVM::new(vec![4,3,99,-100],  10,VecDeque::new());
		let output = vm.run();
		assert_eq!(output, vec![-100]);
	}

	#[test]
	fn test_negative_input() {
		let mut vm = IntVM::new(vec![3,0,4,0,99], 10, VecDeque::from(vec![-100]));
		let output = vm.run();
		assert_eq!(output, vec![-100]);
	}

	#[test]
	fn test_day5_part1() {
		let day5 = vec![3,225,1,225,6,6,1100,1,238,225,104,0,101,71,150,224,101,-123,224,224,4,224,102,8,223,223,101,2,224,224,1,224,223,223,2,205,209,224,1001,224,-3403,224,4,224,1002,223,8,223,101,1,224,224,1,223,224,223,1101,55,24,224,1001,224,-79,224,4,224,1002,223,8,223,101,1,224,224,1,223,224,223,1,153,218,224,1001,224,-109,224,4,224,1002,223,8,223,101,5,224,224,1,224,223,223,1002,201,72,224,1001,224,-2088,224,4,224,102,8,223,223,101,3,224,224,1,223,224,223,1102,70,29,225,102,5,214,224,101,-250,224,224,4,224,1002,223,8,223,1001,224,3,224,1,223,224,223,1101,12,52,225,1101,60,71,225,1001,123,41,224,1001,224,-111,224,4,224,102,8,223,223,1001,224,2,224,1,223,224,223,1102,78,66,224,1001,224,-5148,224,4,224,1002,223,8,223,1001,224,2,224,1,223,224,223,1101,29,77,225,1102,41,67,225,1102,83,32,225,1101,93,50,225,1102,53,49,225,4,223,99,0,0,0,677,0,0,0,0,0,0,0,0,0,0,0,1105,0,99999,1105,227,247,1105,1,99999,1005,227,99999,1005,0,256,1105,1,99999,1106,227,99999,1106,0,265,1105,1,99999,1006,0,99999,1006,227,274,1105,1,99999,1105,1,280,1105,1,99999,1,225,225,225,1101,294,0,0,105,1,0,1105,1,99999,1106,0,300,1105,1,99999,1,225,225,225,1101,314,0,0,106,0,0,1105,1,99999,1107,677,677,224,1002,223,2,223,1005,224,329,101,1,223,223,7,677,677,224,1002,223,2,223,1005,224,344,1001,223,1,223,7,226,677,224,102,2,223,223,1006,224,359,101,1,223,223,1108,226,226,224,1002,223,2,223,1005,224,374,1001,223,1,223,8,226,677,224,1002,223,2,223,1006,224,389,1001,223,1,223,1108,226,677,224,1002,223,2,223,1006,224,404,101,1,223,223,1107,677,226,224,102,2,223,223,1006,224,419,101,1,223,223,1007,677,677,224,1002,223,2,223,1005,224,434,101,1,223,223,7,677,226,224,102,2,223,223,1006,224,449,1001,223,1,223,1008,226,677,224,1002,223,2,223,1006,224,464,101,1,223,223,8,677,677,224,1002,223,2,223,1006,224,479,101,1,223,223,108,226,226,224,102,2,223,223,1005,224,494,101,1,223,223,1107,226,677,224,1002,223,2,223,1006,224,509,101,1,223,223,107,226,226,224,1002,223,2,223,1006,224,524,1001,223,1,223,107,677,677,224,1002,223,2,223,1005,224,539,101,1,223,223,1007,226,226,224,102,2,223,223,1006,224,554,101,1,223,223,108,677,677,224,102,2,223,223,1005,224,569,101,1,223,223,107,677,226,224,102,2,223,223,1005,224,584,101,1,223,223,1008,226,226,224,102,2,223,223,1006,224,599,101,1,223,223,1108,677,226,224,1002,223,2,223,1006,224,614,101,1,223,223,8,677,226,224,102,2,223,223,1005,224,629,1001,223,1,223,1008,677,677,224,102,2,223,223,1006,224,644,101,1,223,223,1007,226,677,224,102,2,223,223,1005,224,659,101,1,223,223,108,226,677,224,102,2,223,223,1006,224,674,101,1,223,223,4,223,99,226];
		let mut vm = IntVM::new(day5, 1000, VecDeque::from(vec![1]));
		let output = vm.run();
		assert_eq!(output, vec![0,0,0,0,0,0,0,0,0,4511442]);
	}

	#[test]
	fn test_day5_part2() {
		let day5 = vec![3,225,1,225,6,6,1100,1,238,225,104,0,101,71,150,224,101,-123,224,224,4,224,102,8,223,223,101,2,224,224,1,224,223,223,2,205,209,224,1001,224,-3403,224,4,224,1002,223,8,223,101,1,224,224,1,223,224,223,1101,55,24,224,1001,224,-79,224,4,224,1002,223,8,223,101,1,224,224,1,223,224,223,1,153,218,224,1001,224,-109,224,4,224,1002,223,8,223,101,5,224,224,1,224,223,223,1002,201,72,224,1001,224,-2088,224,4,224,102,8,223,223,101,3,224,224,1,223,224,223,1102,70,29,225,102,5,214,224,101,-250,224,224,4,224,1002,223,8,223,1001,224,3,224,1,223,224,223,1101,12,52,225,1101,60,71,225,1001,123,41,224,1001,224,-111,224,4,224,102,8,223,223,1001,224,2,224,1,223,224,223,1102,78,66,224,1001,224,-5148,224,4,224,1002,223,8,223,1001,224,2,224,1,223,224,223,1101,29,77,225,1102,41,67,225,1102,83,32,225,1101,93,50,225,1102,53,49,225,4,223,99,0,0,0,677,0,0,0,0,0,0,0,0,0,0,0,1105,0,99999,1105,227,247,1105,1,99999,1005,227,99999,1005,0,256,1105,1,99999,1106,227,99999,1106,0,265,1105,1,99999,1006,0,99999,1006,227,274,1105,1,99999,1105,1,280,1105,1,99999,1,225,225,225,1101,294,0,0,105,1,0,1105,1,99999,1106,0,300,1105,1,99999,1,225,225,225,1101,314,0,0,106,0,0,1105,1,99999,1107,677,677,224,1002,223,2,223,1005,224,329,101,1,223,223,7,677,677,224,1002,223,2,223,1005,224,344,1001,223,1,223,7,226,677,224,102,2,223,223,1006,224,359,101,1,223,223,1108,226,226,224,1002,223,2,223,1005,224,374,1001,223,1,223,8,226,677,224,1002,223,2,223,1006,224,389,1001,223,1,223,1108,226,677,224,1002,223,2,223,1006,224,404,101,1,223,223,1107,677,226,224,102,2,223,223,1006,224,419,101,1,223,223,1007,677,677,224,1002,223,2,223,1005,224,434,101,1,223,223,7,677,226,224,102,2,223,223,1006,224,449,1001,223,1,223,1008,226,677,224,1002,223,2,223,1006,224,464,101,1,223,223,8,677,677,224,1002,223,2,223,1006,224,479,101,1,223,223,108,226,226,224,102,2,223,223,1005,224,494,101,1,223,223,1107,226,677,224,1002,223,2,223,1006,224,509,101,1,223,223,107,226,226,224,1002,223,2,223,1006,224,524,1001,223,1,223,107,677,677,224,1002,223,2,223,1005,224,539,101,1,223,223,1007,226,226,224,102,2,223,223,1006,224,554,101,1,223,223,108,677,677,224,102,2,223,223,1005,224,569,101,1,223,223,107,677,226,224,102,2,223,223,1005,224,584,101,1,223,223,1008,226,226,224,102,2,223,223,1006,224,599,101,1,223,223,1108,677,226,224,1002,223,2,223,1006,224,614,101,1,223,223,8,677,226,224,102,2,223,223,1005,224,629,1001,223,1,223,1008,677,677,224,102,2,223,223,1006,224,644,101,1,223,223,1007,226,677,224,102,2,223,223,1005,224,659,101,1,223,223,108,226,677,224,102,2,223,223,1006,224,674,101,1,223,223,4,223,99,226];
		let mut vm = IntVM::new(day5, 1000, VecDeque::from(vec![5]));
		let output = vm.run();
		assert_eq!(output, vec![12648139]);
	}

	#[test]
	fn test_relative_offset() {
		let mut vm = IntVM::new(vec![109,1,204,-1,1001,100,1,100,1008,100,16,101,1006,101,0,99], 100, VecDeque::new());
		let output = vm.run();
		assert_eq!(output, vec![109,1,204,-1,1001,100,1,100,1008,100,16,101,1006,101,0,99]);
	}

	#[test]
	fn test_day9() {
		let day9 = vec![1102,34463338,34463338,63,1007,63,34463338,63,1005,63,53,1101,3,0,1000,109,988,209,12,9,1000,209,6,209,3,203,0,1008,1000,1,63,1005,63,65,1008,1000,2,63,1005,63,904,1008,1000,0,63,1005,63,58,4,25,104,0,99,4,0,104,0,99,4,17,104,0,99,0,0,1101,37,0,1005,1101,30,0,1013,1102,1,33,1019,1102,1,25,1003,1102,1,28,1018,1101,26,0,1006,1102,1,866,1029,1101,760,0,1023,1102,39,1,1012,1102,23,1,1009,1101,281,0,1026,1102,1,20,1011,1102,1,34,1008,1101,0,36,1017,1101,38,0,1000,1102,0,1,1020,1102,278,1,1027,1101,21,0,1010,1102,875,1,1028,1101,0,212,1025,1102,1,1,1021,1102,1,24,1014,1102,763,1,1022,1101,0,31,1007,1102,1,221,1024,1101,0,32,1002,1102,1,29,1004,1102,1,35,1016,1102,22,1,1015,1101,0,27,1001,109,9,1207,-6,26,63,1005,63,199,4,187,1105,1,203,1001,64,1,64,1002,64,2,64,109,19,2105,1,-4,4,209,1001,64,1,64,1106,0,221,1002,64,2,64,109,-33,1207,5,37,63,1005,63,241,1001,64,1,64,1106,0,243,4,227,1002,64,2,64,109,16,2102,1,-2,63,1008,63,23,63,1005,63,269,4,249,1001,64,1,64,1106,0,269,1002,64,2,64,109,16,2106,0,0,1106,0,287,4,275,1001,64,1,64,1002,64,2,64,109,-11,21101,40,0,0,1008,1016,38,63,1005,63,311,1001,64,1,64,1105,1,313,4,293,1002,64,2,64,109,4,21107,41,40,-9,1005,1011,329,1105,1,335,4,319,1001,64,1,64,1002,64,2,64,109,-14,21108,42,42,5,1005,1011,353,4,341,1106,0,357,1001,64,1,64,1002,64,2,64,109,2,2107,33,0,63,1005,63,379,4,363,1001,64,1,64,1105,1,379,1002,64,2,64,109,-7,1201,2,0,63,1008,63,25,63,1005,63,401,4,385,1105,1,405,1001,64,1,64,1002,64,2,64,109,11,1201,-8,0,63,1008,63,28,63,1005,63,429,1001,64,1,64,1106,0,431,4,411,1002,64,2,64,109,-7,2108,26,1,63,1005,63,449,4,437,1105,1,453,1001,64,1,64,1002,64,2,64,109,9,1206,7,465,1105,1,471,4,459,1001,64,1,64,1002,64,2,64,109,4,21102,43,1,-3,1008,1015,42,63,1005,63,491,1106,0,497,4,477,1001,64,1,64,1002,64,2,64,109,7,21108,44,43,-7,1005,1018,517,1001,64,1,64,1105,1,519,4,503,1002,64,2,64,109,-28,2101,0,7,63,1008,63,29,63,1005,63,545,4,525,1001,64,1,64,1105,1,545,1002,64,2,64,109,11,2107,28,-7,63,1005,63,561,1105,1,567,4,551,1001,64,1,64,1002,64,2,64,109,-4,2101,0,-1,63,1008,63,26,63,1005,63,587,1105,1,593,4,573,1001,64,1,64,1002,64,2,64,109,9,1206,7,607,4,599,1105,1,611,1001,64,1,64,1002,64,2,64,109,-10,1208,1,27,63,1005,63,627,1106,0,633,4,617,1001,64,1,64,1002,64,2,64,109,26,1205,-9,649,1001,64,1,64,1106,0,651,4,639,1002,64,2,64,109,-20,1208,0,23,63,1005,63,669,4,657,1105,1,673,1001,64,1,64,1002,64,2,64,109,-7,2102,1,1,63,1008,63,28,63,1005,63,693,1105,1,699,4,679,1001,64,1,64,1002,64,2,64,109,18,21102,45,1,-6,1008,1014,45,63,1005,63,725,4,705,1001,64,1,64,1106,0,725,1002,64,2,64,109,-23,1202,6,1,63,1008,63,25,63,1005,63,751,4,731,1001,64,1,64,1106,0,751,1002,64,2,64,109,20,2105,1,6,1106,0,769,4,757,1001,64,1,64,1002,64,2,64,109,-22,2108,39,10,63,1005,63,789,1001,64,1,64,1106,0,791,4,775,1002,64,2,64,109,3,1202,6,1,63,1008,63,32,63,1005,63,815,1001,64,1,64,1105,1,817,4,797,1002,64,2,64,109,23,21107,46,47,-9,1005,1012,835,4,823,1106,0,839,1001,64,1,64,1002,64,2,64,109,1,1205,-1,853,4,845,1105,1,857,1001,64,1,64,1002,64,2,64,109,-2,2106,0,8,4,863,1001,64,1,64,1105,1,875,1002,64,2,64,109,-8,21101,47,0,-2,1008,1010,47,63,1005,63,897,4,881,1106,0,901,1001,64,1,64,4,64,99,21102,27,1,1,21101,0,915,0,1105,1,922,21201,1,27810,1,204,1,99,109,3,1207,-2,3,63,1005,63,964,21201,-2,-1,1,21102,1,942,0,1106,0,922,22101,0,1,-1,21201,-2,-3,1,21101,957,0,0,1106,0,922,22201,1,-1,-2,1106,0,968,22101,0,-2,-2,109,-3,2106,0,0];
		let mut vm1 = IntVM::new(day9.clone(), 1000, VecDeque::from(vec![1]));
		let output = vm1.run();
		assert_eq!(output, vec![2775723069]);
		let mut vm1 = IntVM::new(day9.clone(), 1000, VecDeque::from(vec![2]));
		let output = vm1.run();
		assert_eq!(output, vec![49115]);
	}
}
